```JavaScript
/*
	文章来源：http://blog.csdn.net/zaifendou/article/details/5746988
	在线正则：http://www.regexlab.com/zh/workshop.htm?pat=a.%5Cd&txt=aaa100
	文章错误：文章中大部分用于转义的"/"都写错啦，应该是"\"
*/
1. 正则表达式规则
	1.1 普通字符
		字母、数字、汉字、下划线、以及后边章节中没有特殊定义的标点符号，都是 "普通字符"。
		表达式中的普通字符， 在匹配一个字符串的时候， 匹配与之相同的一个字符。
		举例1： 表达式 "c"，在匹配字符串 "abcde"时， 匹配结果是： 成功； 匹配到的内容是： "c"；
		匹配到的位置是：开始于2，结束于3。（ 注：下标从0开始还是从1开始， 因当前编程语言的不同而可能不同）
		举例2： 表达式 "bcd"，在匹配字符串 "abcde"时， 匹配结果是： 成功； 匹配到的内容是： "bcd"；
		匹配到的位置是： 开始于1， 结束于4。
	1.2 简单的转义字符
	一些不便书写的字符， 采用在前面加 "\"的方法。 这些字符其实我们都已经熟知了。
	表达式      可匹配
	\r, \n      代表回车和换行符
	\t          制表符
	\\          代表 "\"
	本身还有其他一些在后边章节中有特殊用处的标点符号，在前面加 "\"后，就代表该符号本身。
	比如：^ , $ 都有特殊意义，如果要想匹配字符串中 "^"和"$"字符，则表达式就需要写成 "\^"和 "\$"。
	表达式      可匹配
    \^          匹配 ^ 符号本身
	\$          匹配 $ 符号本身
	\.          匹配小数点（.）本身
	这些转义字符的匹配方法与 "普通字符"是类似的。也是匹配与之相同的一个字符。
	举例1： 表达式 "\$d"，在匹配字符串 "abc$de"时， 匹配结果是： 成功； 匹配到的内容是： "$d"；
	匹配到的位置是： 开始于3， 结束于5。
	1.3 能够与 '多种字符'匹配的表达式
	正则表达式中的一些表示方法， 可以匹配 '多种字符'其中的任意一个字符。 
	比如， 表达式 "\d"可以匹配任意一个数字。 虽然可以匹配其中任意字符，但是只能是一个，不是多个。 
	这就好比玩扑克牌时候， 大小王可以代替任意一张牌， 但是只能代替一张牌。
	表达式      可匹配
	\d          任意一个数字， 0~9 中的任意一个
    \w          任意一个字母或数字或下划线， 也就是 A~Z, a~z, 0~9, _ 中任意一个
	\s          包括空格、 制表符、 换页符等空白字符的其中任意一个
    .           小数点可以匹配除了换行符（ \ n） 以外的任意一个字符
	举例1：表达式 "\d\d"，在匹配 "abc123"时，匹配的结果是：成功； 匹配到的内容是： "12"；
	匹配到的位置是： 开始于3， 结束于5。
	举例2： 表达式 "a.\d"，在匹配 "aaa100"时，匹配的结果是：成功；匹配到的内容是： "aa1"；
	匹配到的位置是： 开始于1， 结束于4。
	1.4 自定义能够匹配 '多种字符'的表达式
	使用方括号[] 包含一系列字符，能够匹配其中任意一个字符。 
	用[ ^ ] 包含一系列字符， 则能够匹配其中字符之外的任意一个字符。
	同样的道理， 虽然可以匹配其中任意一个， 但是只能是一个， 不是多个。
	表达式     可匹配
	[ab5@]	   匹配 "a" 或 "b" 或 "5" 或 "@"
    [^abc]     匹配 "a", "b", "c"之外的任意一个字符
	[f-k]      匹配 "f"~"k"之间的任意一个字母
	[^A-F0-3]  匹配 "A"~"F", "0"~"3"之外的任意一个字符
	举例1： 表达式 "[bcd][bcd]"匹配 "abc123"时， 匹配的结果是： 成功； 匹配到的内容是： "bc"；
	匹配到的位置是： 开始于1， 结束于3。
	举例2： 表达式 "[^abc]"匹配 "abc123"时， 匹配的结果是： 成功； 匹配到的内容是： "1"；
	匹配到的位置是： 开始于3， 结束于4。
	1.5 修饰匹配次数的特殊符号
	前面章节中讲到的表达式， 无论是只能匹配一种字符的表达式， 还是可以匹配多种字符其中任意一个的表达式， 都只能匹配一次。 
	如果使用表达式再加上修饰匹配次数的特殊符号， 那么不用重复书写表达式就可以重复匹配。
	使用方法是： "次数修饰"放在 "被修饰的表达式"后边。 
	比如： "[bcd][bcd]"可以写成 "[bcd]{2}"。
	表达式     作用
	{n}        表达式重复n次，比如： "\w{2}"相当于 "\w\w"；"a{5}"相当于 "aaaaa"
	{m,n}      表达式至少重复m次， 最多重复n次， 比如： "ba{1,3}"可以匹配 "ba"或 "baa"或 "baaa"
	{m,}	   表达式至少重复m次， 比如："\w\d{2,}"可以匹配 "a12", "_456", "M12344"...
	?          匹配表达式0次或者1次， 相当于{0, 1}，比如： "a[cd]?"可以匹配 "a", "ac", "ad"
	+          表达式至少出现1次， 相当于 {1,}，比如： "a+b"可以匹配 "ab", "aab", "aaab"...
	*          表达式不出现或出现任意次， 相当于 {0,}，比如： "\^*b"可以匹配 "b", "^^^b"...
	举例1： 表达式 "\d+\.?\d*"在匹配 "It costs $12.5"时， 匹配的结果是： 成功； 匹配到的内容是： "12.5"；
	匹配到的位置是： 开始于10， 结束于14。
	举例2： 表达式 "go{2,8}gle"
	在匹配 "Ads by goooooogle"时， 匹配的结果是： 成功； 匹配到的内容是： "goooooogle"；
	匹配到的位置是： 开始于7， 结束于17。
	1.6 其他一些代表抽象意义的特殊符号
	一些符号在表达式中代表抽象的特殊意义：
	表达式     作用
	^		   与字符串开始的地方匹配， 不匹配任何字符
	$          与字符串结束的地方匹配， 不匹配任何字符
	\b         匹配一个单词边界， 也就是单词和空格之间的位置， 不匹配任何字符
	进一步的文字说明仍然比较抽象， 因此， 举例帮助大家理解。
	举例1： 表达式 "^aaa"在匹配 "xxx aaa xxx"时， 匹配结果是： 失败。 
	因为 "^"要求与字符串开始的地方匹配， 因此， 只有当 "aaa"位于字符串的开头的时候， "^aaa"才能匹配， 比如： "aaa xxx xxx"。
	举例2： 表达式 "aaa$"在匹配 "xxx aaa xxx"时， 匹配结果是： 失败。 
	因为 "$"要求与字符串结束的地方匹配， 因此， 只有当 "aaa"位于字符串的结尾的时候， "aaa$"才能匹配， 比如： "xxx xxx aaa"。
	举例3： 表达式 ".\b."在匹配 "@@@abc"时， 匹配结果是： 成功； 匹配到的内容是： "@a"；
	匹配到的位置是： 开始于2， 结束于4。
	进一步说明： "\b"与 "^"和 "$"类似， 本身不匹配任何字符， 但是它要求它在匹配结果中所处位置的左右两边， 
	其中一边是 "\w"范围， 另一边是 非 "\w"的范围。
	举例4： 表达式 "\bend\b"在匹配 "weekend,endfor,end"时， 匹配结果是： 成功； 匹配到的内容是： "end"；
	匹配到的位置是： 开始于15， 结束于18。
	一些符号可以影响表达式内部的子表达式之间的关系：
	表达式     作用
	|          左右两边表达式之间 "或"关系， 匹配左边或者右边
	()		   (1).在被修饰匹配次数的时候， 括号中的表达式可以作为整体被修饰
			   (2).取匹配结果的时候， 括号中的表达式匹配到的内容可以被单独得到
	举例5： 表达式 "Tom|Jack"在匹配字符串 "I'm Tom, he is Jack"时， 匹配结果是： 成功； 
	匹配到的内容是： "Tom"；匹配到的位置是： 开始于4， 结束于7。 
	匹配下一个时， 匹配结果是： 成功； 匹配到的内容是： "Jack"；匹配到的位置时： 开始于15， 结束于19。
	举例6： 表达式 "(go\s*)+"在匹配 "Let's go go go!"时， 匹配结果是： 成功； 匹配到内容是： "go go go"；
	匹配到的位置是： 开始于6， 结束于14。
	举例7： 表达式 "￥(\d+\.?\d*)"在匹配 "＄10.9,￥20.5"时， 匹配的结果是： 成功； 匹配到的内容是： "￥20.5"；
	匹配到的位置是： 开始于6， 结束于10。 单独获取括号范围匹配到的内容是： "20.5"。

2. 正则表达式中的一些高级规则
	2.1 匹配次数中的贪婪与非贪婪
		在使用修饰匹配次数的特殊符号时， 有几种表示方法可以使同一个表达式能够匹配不同的次数， 比如： "{m,n}", "{m,}", "?", "*", "+"，
		具体匹配的次数随被匹配的字符串而定。 这种重复匹配不定次数的表达式在匹配过程中， 总是尽可能多的匹配。 比如， 针对文本 "dxxxdxxxd"，
		举例如下：
		表达式          匹配结果
		(d)(\w+)        "\w+"将匹配第一个 "d"之后的所有字符 "xxxdxxxd"
		(d)(\w+)(d)     "\w+"将匹配第一个 "d"和最后一个 "d"之间的所有字符 "xxxdxxx"。
						虽然 "\w+"也能够匹配上最后一个 "d"，但是为了使整个表达式匹配成功， 
						"\w+"可以 "让出"它本来能够匹配的最后一个 "d"

		由此可见， "\w+"在匹配的时候， 总是尽可能多的匹配符合它规则的字符。 虽然第二个举例中， 它没有匹配最后一个 "d"，
		但那也是为了让整个表达式能够匹配成功。 同理， 带 "*"和 "{m,n}"的表达式都是尽可能地多匹配， 
		带 "?"的表达式在可匹配可不匹配的时候， 也是尽可能的 "要匹配"。这种匹配原则就叫作 "贪婪"模式。

		非贪婪模式：
		在修饰匹配次数的特殊符号后再加上一个 "?"号， 则可以使匹配次数不定的表达式尽可能少的匹配， 使可匹配可不匹配的表达式， 尽可能的 "不匹配"。
		这种匹配原则叫作 "非贪婪"模式， 也叫作 "勉强"模式。 如果少匹配就会导致整个表达式匹配失败的时候， 
		与贪婪模式类似， 非贪婪模式会最小限度的再匹配一些， 以使整个表达式匹配成功。 举例如下， 针对文本 "dxxxdxxxd"
		举例：
		表达式          匹配结果
		(d)(\w+?)		"\w+?"将尽可能少的匹配第一个 "d"之后的字符， 结果是： "\w+?"只匹配了一个 "x"
		(d)(\w+?)(d)    为了让整个表达式匹配成功， "\w+?"不得不匹配 "xxx"才可以让后边的 "d"匹配， 从而使整个表达式匹配成功。 
						因此， 结果是： "\w+?"匹配 "xxx"
		更多的情况， 举例如下：
		举例1： 表达式 "<td>(.*)</td>"与字符串 "<td><p>aa<\p><\td> <td><p>bb<\p></td>"匹配时， 匹配的结果是： 成功； 
		匹配到的内容是 "<td><p>aa<\p></td> <td><p>bb<\p></td>"整个字符串， 表达式中的 "<\/td>"将与字符串中最后一个 "</td>"匹配。
		举例2： 相比之下， 表达式 "<td>(.*?)<\td>"匹配举例1中同样的字符串时， 将只得到 "<td><p>aa<\p></td>"，
		再次匹配下一个时， 可以得到第二个 "<td><p>bb<\p></td>"。
	2.2 反向引用 \ 1, \2...
		表达式在匹配时， 表达式引擎会将小括号 "( )"包含的表达式所匹配到的字符串记录下来。 
		在获取匹配结果的时候， 小括号包含的表达式所匹配到的字符串可以单独获取。 
		这一点，在前面的举例中，已经多次展示了。 在实际应用场合中，当用某种边界来查找， 
		而所要获取的内容又不包含边界时， 必须使用小括号来指定所要的范围。 
		比如前面的 "<td>(.*?)<\td>"。其实， "小括号包含的表达式所匹配到的字符串"不仅是在匹配结束后才可以使用， 
		在匹配过程中也可以使用。 表达式后边的部分， 可以引用前面 "括号内的子匹配已经匹配到的字符串"。
		引用方法是 "\"加上一个数字。 "\1"引用第1对括号内匹配到的字符串， "\2"引用第2对括号内匹配到的字符串…… 
		以此类推， 如果一对括号内包含另一对括号， 则外层的括号先排序号。 换句话说， 哪一对的左括号 "("在前， 那这一对就先排序号。
		举例如下：
		举例1： 表达式 "('|")(.* ? )(\1)" 在匹配 " 'Hello', "World" " 时，匹配结果是：成功；匹配到的内容是：" 'Hello' "。
		再次匹配下一个时，可以匹配到 " "World" "。
		举例2： 表达式 "(\w)\1{4,}"在匹配 "aa bbbb abcdefg ccccc 111121111 999999999"时， 匹配结果是： 成功； 匹配到的内容是 "ccccc"。
		再次匹配下一个时， 将得到 999999999。 这个表达式要求 "\w"范围的字符至少重复5次， 注意与 "\w{5,}"之间的区别。
		举例3： 表达式 "<(\w+)\s*(\w+(=('|").* ? \4)?\s * ) * > .* ? < /\1>" 在匹配 "<td id='td1' style='bgcolor:white'><\td>" 时，匹配结果是成功。
		如果 "<td>" 与 "<\td>" 不配对，则会匹配失败；如果改成其他配对，也可以匹配成功。
	2.3 预搜索， 不匹配； 反向预搜索， 不匹配
		前面的章节中， 我讲到了几个代表抽象意义的特殊符号： "^"，"$"，"\b"。它们都有一个共同点， 
		那就是： 它们本身不匹配任何字符， 只是对 "字符串的两头"或者 "字符之间的缝隙"附加了一个条件。 
		理解到这个概念以后， 本节将继续介绍另外一种对 "两头"或者 "缝隙"附加条件的， 更加灵活的表示方法。
		正向预搜索： "(?=xxxxx)"，"(?!xxxxx)"
		格式： "(?=xxxxx)"，在被匹配的字符串中， 它对所处的 "缝隙"或者 "两头"
		附加的条件是： 所在缝隙的右侧， 必须能够匹配上 xxxxx 这部分的表达式。 因为它只是在此作为这个缝隙上附加的条件， 
		所以它并不影响后边的表达式去真正匹配这个缝隙之后的字符。 
		这就类似 "\b"，本身不匹配任何字符。 "\b"是将所在缝隙之前、 之后的字符取来进行了一下判断， 不会影响后边的表达式来真正的匹配。
		举例1： 表达式 "Windows (?=NT|XP)"在匹配 "Windows 98, Windows NT, Windows 2000"时， 将只匹配 "Windows NT"中的 "Windows "，其他的 "Windows "字样则不被匹配。
		举例2： 表达式 "(\w)((?=\1\1\1)(\1))+"在匹配字符串 "aaa ffffff 999999999"时， 将可以匹配6个 "f"的前4个， 
		可以匹配9个 "9"的前7个。 这个表达式可以读解成： 重复4次以上的字母数字， 则匹配其剩下最后2位之前的部分。 
		当然， 这个表达式可以不这样写， 在此的目的是作为演示之用。
		格式： "(?!xxxxx)"，所在缝隙的右侧， 必须不能匹配 xxxxx 这部分表达式。
		举例3： 表达式 "((?!\bstop\b).)+"在匹配 "fdjka ljfdl stop fjdsla fdj"时， 将从头一直匹配到 "stop"之前的位置， 如果字符串中没有 "stop"，则匹配整个字符串。
		举例4： 表达式 "do(?!\w)"在匹配字符串 "done, do, dog"时， 只能匹配 "do"。在本条举例中， "do"后边使用 "(?!\w)"和使用 "\b"效果是一样的。
		反向预搜索： "(?<=xxxxx)"，"(?<!xxxxx)"
		这两种格式的概念和正向预搜索是类似的， 反向预搜索要求的条件是： 所在缝隙的 "左侧"，
		两种格式分别要求必须能够匹配和必须不能够匹配指定表达式， 而不是去判断右侧。 与 "正向预搜索"
		一样的是： 它们都是对所在缝隙的一种附加条件， 本身都不匹配任何字符。
		举例5： 表达式 "(?<=\d{4})\d+(?=\d{4})"在匹配 "1234567890123456"时， 
		将匹配除了前4个数字和后4个数字之外的中间8个数字。 
		由于 JScript.RegExp 不支持反向预搜索， 因此， 本条举例不能够进行演示。 
		很多其他的引擎可以支持反向预搜索， 比如： Java 1.4 以上的 java.util.regex 包，
		.NET 中System.Text.RegularExpressions 命名空间， 以及本站推荐的最简单易用的 DEELX 正则引擎。

3. 其他通用规则 还有一些在各个正则表达式引擎之间比较通用的规则， 在前面的讲解过程中没有提到。

	3.1 表达式中， 可以使用 "\xXX"和 "\uXXXX"表示一个字符（ "X"表示一个十六进制数）
	形式        字符范围
	\xXX           编号在 0~255 范围的字符， 比如： 空格可以使用 "\x20"表示
    \uXXXX         任何字符可以使用 "\u"再加上其编号的4位十六进制数表示， 比如： "\中"

	3.2 在表达式 "\s"，"\d"，"\w"，"\b"表示特殊意义的同时， 对应的大写字母表示相反的意义
	表达式      可匹配
	\S          匹配所有非空白字符（ "\s"可匹配各个空白字符）
    \D          匹配所有的非数字字符
    \W          匹配所有的字母、数字、下划线以外的字符
    \B          匹配非单词边界，即左右两边都是 "\w"范围或者左右两边都不是 "\w"范围时的字符缝隙

	3.3 在表达式中有特殊意义， 需要添加 "\"才能匹配该字符本身的字符汇总
	字符        说明
    ^           匹配输入字符串的开始位置。 要匹配 "^"字符本身， 请使用 "\^"
    $           匹配输入字符串的结尾位置。 要匹配 "$"字符本身， 请使用 "\$"
    ()          标记一个子表达式的开始和结束位置。 要匹配小括号， 请使用 "\("和 "\)"
    []          用来自定义能够匹配 '多种字符'的表达式。 要匹配中括号， 请使用 "\["和 "\]"
    {}          修饰匹配次数的符号。 要匹配大括号， 请使用 "\{"和 "\}"
    .           匹配除了换行符（ \ n） 以外的任意一个字符。 要匹配小数点本身， 请使用 "\."
    ?           修饰匹配次数为 0 次或 1 次。 要匹配 "?"字符本身， 请使用 "\?"
    +           修饰匹配次数为至少 1 次。 要匹配 "+"字符本身， 请使用 "\+"
    *           修饰匹配次数为 0 次或任意次。 要匹配 "*"字符本身， 请使用 "\*"
    |           左右两边表达式之间 "或"关系。 匹配 "|"本身， 请使用 "\|"
	3.4 括号 "( )"内的子表达式， 如果希望匹配结果不进行记录供以后使用， 可以使用 "(?:xxxxx)"格式
	举例1： 表达式 "(?:(\w)\1)+"匹配 "a bbccdd efg"时， 结果是 "bbccdd"。
	括号 "(?:)"范围的匹配结果不进行记录， 因此 "(\w)"使用 "\1"来引用。
	3.5 常用的表达式属性设置简介： Ignorecase， Singleline， Multiline， Global
	表达式属性  说明
	Ignorecase  默认情况下， 表达式中的字母是要区分大小写的。 配置为 Ignorecase 可使匹配时不区分大小写。 有的表达式引擎， 把 "大小写"
			    概念延伸至 UNICODE 范围的大小写。

	Singleline  默认情况下， 小数点 "."匹配除了换行符（ \ n） 以外的字符。 配置为 Singleline 可使小数点可匹配包括换行符在内的所有字符。
	Multiline   默认情况下， 表达式 "^" 和 "$"只匹配字符串的开始① 和结尾④ 位置。 如：① xxxxxxxxx② \ n③ xxxxxxxxx④配置为 Multiline 可以使 "^"
				匹配① 外， 还可以匹配换行符之后， 下一行开始前③ 的位置， 使 "$"匹配④ 外， 还可以匹配换行符之前， 一行结束② 的位置。

	Global      主要在将表达式用来替换时起作用， 配置为 Global 表示替换所有的匹配。



4. 其他提示 
	4.1 如果想要了解高级的正则引擎还支持那些复杂的正则语法， 可参见本站 DEELX 正则引擎的说明文档。
	4.2 如果要要求表达式所匹配的内容是整个字符串， 而不是从字符串中找一部分， 那么可以在表达式的首尾使用 "^"和 "$"，
	比如： "^\d+$"要求整个字符串只有数字。
	4.3 如果要求匹配的内容是一个完整的单词， 而不会是单词的一部分， 那么在表达式首尾使用 "\b"，
	比如： 使用 "\b(if|while|else|void|int……)\b"来匹配程序中的关键字。
	4.4 表达式不要匹配空字符串。 否则会一直得到匹配成功， 而结果什么都没有匹配到。 
	比如： 准备写一个匹配 "123"、"123."、"123.5"、".5"这几种形式的表达式时， 整数、 小数点、 小数数字都可以省略， 
	但是不要将表达式写成： "\d*\.?\d*"，因为如果什么都没有， 这个表达式也可以匹配成功。 更好的写法是： "\d+\.?\d*|\.\d+"。
    4.5 能匹配空字符串的子匹配不要循环无限次。 如果括号内的子表达式中的每一部分都可以匹配 0 次， 而这个括号整体又可以匹配无限次， 
    那么情况可能比上一条所说的更严重， 匹配过程中可能死循环。 虽然现在有些正则表达式引擎已经通过办法避免了这种情况出现死循环了， 
    比如.NET 的正则表达式， 但是我们仍然应该尽量避免出现这种情况。 如果我们在写表达式时遇到了死循环， 也可以从这一点入手， 查找一下是否是本条所说的原因。
	4.6 合理选择贪婪模式与非贪婪模式， 参见话题讨论。
	4.7 或 "|"的左右两边， 对某个字符最好只有一边可以匹配， 这样， 不会因为 "|"两边的表达式因为交换位置而有所不同。

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --下一篇

1， 定义正则表达式
	1） 定义正则表达式有两种形式， 一种是普通方式， 一种是构造函数方式。 
	2） 普通方式：
			var reg = /表达式/附加参数
			表达式： 一个字符串， 代表了某种规则， 其中可以使用某些特殊字符， 来代表特殊的规则， 后面会详细说明。 
			附加参数： 用来扩展表达式的含义， 目前主要有三个参数： 
			g： 代表可以进行全局匹配。 
			i： 代表不区分大小写匹配。 
			m： 代表可以进行多行匹配。 
			上面三个参数， 可以任意组合， 代表复合含义， 当然也可以不加参数。 
			例子：
			var reg = /a*b/;
			var reg = /abc+f/g; 
	3） 构造函数方式：
			var reg = new RegExp(“表达式”, ”附加参数”); 其中“ 表达式” 与“ 附加参数” 的含义与上面那种定义方式中的含义相同。 
			例子：
			var reg = new RegExp(“a * b”);
			var reg = new RegExp(“abc + f”, ”g”); 
	4） 普通方式与构造函数方式的区别 普通方式中的表达式必须是一个常量字符串， 而构造函数中的表达式可以是常量字符串， 也可以是一个js变量， 
		例如根据用户的输入来作为表达式参数等等：
			var reg = new RegExp(document.forms[0].exprfiled.value, ”g”);

2， 表达式模式
	1） 表达式模式， 是指表达式的表达方式与样式， 即var reg = /表达式/附加参数中的“ 表达式” 怎样去描述？ 
	2） 从规范上讲， 表达式模式分为简单模式和复合模式。 
	3） 简单模式： 是指通过普通字符的组合来表达的模式， 例如var reg = /abc0d/; 可见简单模式只能表示具体的匹配。 
	4） 复合模式： 是指含有通配符来表达的模式， 例如：var reg = /a+b?\w / ; 其中的 + 、 ? 和 \ w都属于通配符， 代表着特殊的含义。
		因此复合模式可以表达更为抽象化的逻辑。 下面我们着重说一下复合模式中各个通配符的含义及其使用。 
	5) 复合模式中特殊字符的讲解：
		1 > \：在许多编程语言里面被用作转义符，一般来说 \ 符号后面如果跟的是普通字符c， 那么 \ c就代表特殊的含义， 
		例如n本来代表字符n， 但 \ n就代表换行。 \ 符号后面如果跟的是特殊字符c， 那么 \ c就代表普通字符c， 
		例如 \ 一般用作转义符， 但 \\则调表普通字符\。
		Javascript的正则表达式中 \ 的用法与上面相同， 只是不同的编程语言， 特殊字符表可能不太一样罢了。
		2 > ^ ：匹配输入字符串的起始端， 如果是多行匹配， 即表达式的附加参数中含有m， 则也在一个换行符后匹配。 
		例子： \ ^ B \ 匹配“ Bab Bc” 中的第一个B 例子2： \ ^ B \ gm匹配“ Badd B cdaf B dsfB” 中的第一行第一个B， 第三行中的第一个B
		3 > $： 匹配输入字符创的尾端， 如果是多行匹配， 即表达式的附加参数中含有m， 则也在一个换行符前匹配。 与 ^ 的用法相反。 
		例子： \ t$ \ 匹配“ bat” 中的t， 但是不匹配“ hate” 中的t 例子2： \ t$ \ 匹配“ tag at bat” 中第一行的最后一个t和第二行的t。
		4 > * ：匹配前一个字符0次或多次。 例子： \ ab * \匹配“dddabbbbc”中的“abbbb”，也匹配“ddda”中的“a”
		5 > +：匹配前一个字符1次或多次。 例子： \ ab + \匹配“dddabbbbc”中的“abbbb”，但不匹配“ddda”与后面的 {1,}（原型： {n,}）的用法类似
		6 > ? ： ? 的用法比较特殊， 一般来说它用来对前一个字符做0次或1次匹配， 但是它有另外两种特殊的用法： 如果紧跟在 * 、+、 ? 和 {}
		之后， 则表示原始匹配的最小次数匹配， 例如： \ ba * \本来匹配“bbbaaaa”中的“baaaa”，
		但是\ba * ? \则匹配“bbbaaaa”中的“b”（因为*表示0次或多次匹配，而加?应该表示最少次数匹配，即0次匹配）。
		同理： \ ba + ? \则匹配“baaaa”中的“ba”。作为语法结构符号， 使用于前置断言中， 即后面要说到的x( ? = y) 和x( ? != y)
		7 > .：小数点中的“.”号， 匹配任何一个单独的字符， 但是换行符除外。 标准中总共有哪些字符？ 
		请参考： 字符集 例如： \ a.b \ 匹配“ acbaa” 中的“ acb”， 但是不匹配“ abbb”。
		8 > (x)： 表示匹配x(并非特指字符x或者特指一个字符， x表示一个字符串)， 而且匹配会被记住， 在语法中这种() 被称为“ capturing parentheses”
		即捕捉用的小括号。 匹配会被记住， 是因为在表达式提供的函数中， 有些函数返回一个数组， 该数组会保存所匹配的所有字符串， 
		例如exec() 函数。 另外还要注意() 中的x被记住的前提是匹配x。 
		例子1：
		var regx = /a(b)c/;
		var rs = regx.exec(“abcddd”); 从上面可以看出, /a(b)c/匹配“abcddd” 中的“ abc”， 
		因为() 的原因， b也会记录下来， 因此rs返回的数字内容为： {abc, b}
		例子2：
		var regx = /a(b)c/;
		var rs = regx.exec(“acbcddd”); rs返回null， 因为 / a(b) c /不匹配“ acbcddd”， 所以() 中的b不会被记录下来（ 尽管字符串中含有b）
		9 > ( ? : x)： 匹配x， 但不会记住x， 这种格式中的() 被称为“ non - capturing parentheses”， 即非捕捉用的小括号。 
		例子：
		var regx = /a(?:b)c/;
		var rs = regx.exec(“abcddd”); 从上面可以看出, /a(?:b)c/匹配“
		abcddd” 中的“ abc”， 因为( ? : ) 的原因， b不会记录下来， 因此rs返回的数字内容为： {abc}
		10 > X( ? = y)： 匹配x， 仅当后面紧跟着y时。 如果符合匹配， 则只有x会被记住， y不会被记住。 例子：
		var regx = /user(?=name)/;
		var rs = regx.exec(“The username is Mary”); 结果： 匹配成功， 而且rs的值为 {
			user
		}
		11 > X( ? !y)： 匹配x， 仅当后面不紧跟着y时。 如果符合匹配， 则只有x会被记住， y不会被记住。 
		例子：
		var regx = /user(?!name)/;
		var rs = regx.exec(“The user name is Mary”); 结果： 匹配成功， 而且rs的值为 {user}
		例子2：
		var regx = /\d+(?!\.)/;
		var rs = regx.exec(“54.235”); 结果： 匹配成果， rs的值为 {5}，
		不匹配54是因为54后面跟着“.”号， 当然235也匹配， 但是由于exec方法的行为， 235 不会被返回
		12 > x | y： 匹配x或y。 注意如果x和y都匹配上了， 那么只记住x。 
		例子：
		var regx = /beijing|shanghai/;
		var rs = regx.exec(“I love beijing and shanghai”); 结果： 匹配成功， rs的值为 {beijing}，
		虽然shanghai也匹配， 但不会被记住。
		13 > {n}：
		匹配前一个字符的n次出现。 n必须是一个非负数， 当然如果是一个负数或小数也不会报语法错误。 例子：
		var regx = /ab{2}c/;
		var rs = regx.exec(“abbcd”); 结果： 匹配成功， rs的值为： {abbc}。
		14 > {n,}：匹配前一个字符的至少n次出现。 
		例子：
		var regx = /ab{2,}c/;
		var rs = regx.exec(“abbcdabbbc”); 结果： 匹配成功， rs的值为： {abbc}。
		注意为什么abbbc也符合条件为什么没有被记住， 这与exec方法的行为有关， 后面会统一讲解。
		15 > {n, m}：
		匹配前一个字符的至少n次最多m次的出现。 只要n与m为数字， 而且m >= n就不会报语法错误。 
		例子：
		var regx = /ab{2,5}c/;
		var rs = regx.exec(“abbbcd”); 结果： 匹配成功， rs的值为： {abbbc}。
		例子2：
		var regx = /ab{2,2}c/;
		var rs = regx.exec(“abbcd”); 结果： 匹配成功， rs的值为： {abbc}。
		例子3：
		var regx = /ab(2,5)/;
		var rs = regx.exec(“abbbbbbbbbb”); 结果： 匹配成功， rs的值为： {abbbbb}，
		这说明， 如果前一个字符出现多于m次， 则只匹配m次。 另外：
		var regx = /ab(2,5)c/;
		var rs = regx.exec(“abbbbbbbbbbc”); 结果： 匹配失败， rs的值为： null， 为什么匹配失败， 因为b多于5个则b(2, 5) 会匹配前5个b，， 而表达式 \ ab(2, 5) c \ 中b后面是c， 但字符串中5个b之后还是b所以会报错。

		16 > [xyz]： xyz表示一个字符串， 该模式表示匹配[] 中的一个字符， 形式上[xyz] 等同于[x - z]。 
		例子：
		var regx = /a[bc]d/;
		var rs = regx.exec(“abddgg”); 结果： 匹配成功， rs的值为： {abd}
		例子2：
		var regx = /a[bc]d/;
		var rs = regx.exec(“abcd”); 结果： 匹配失败， rs的值为： null， 之所以失败， 是因为[bc] 表示匹配b或c中的一个， 但不会同时匹配。
		17 > [ ^ xyz]： 该模式表示匹配非[] 中的一个字符， 形式上[ ^ xyz] 等同于[ ^ x - z]。 
		例子：
		var regx = /a[^bc]d/;
		var rs = regx.exec(“afddgg”); 结果： 匹配成功， rs的值为： {afd}
		例子2：
		var regx = /a[^bc]d/;
		var rs = regx.exec(“abd”); 结果： 匹配失败， rs的值为：。
		18 > [\b]：匹配退格键。
		19 > \b：匹配一个词的边界符，例如空格和换行符等等，当然匹配换行符时，表达式应该附加参数m。
		例子：
		var regx = /\bc./;
		var rs = regx.exec(“Beijing is a beautiful city”);
		结果： 匹配成功， rs的值为： {ci}，
		注意c前边的空格不会匹配到结果中， 即 {ci}是不正确的。
		20 > \B：代表一个非单词边界。
		例子：
		var regx = /\Bi./;
		var rs = regx.exec(“Beijing is a beautiful city”);
		结果： 匹配成功， rs的值为： {ij}，即匹配了Beijing中的ij。
		21 > \cX，匹配一个控制字符。例如， \cM匹配一个 Control - M 或回车符。 x 的值必须为 A - Z 或 a - z 之一。 否则， 将 c 视为一个原义的’ c’ 字符。（ 实际的例子还需补充）
		22 > \d：匹配一个数字字符，等同于[0-9]。
		例子：
		var regx = /user\d / ;
		var rs = regx.exec(“user1”);
		结果： 匹配成功， rs的值为： {user1}
		23 > \D：匹配一个非数字字符，等同于[^0-9]。
		例子：
		var regx = /user\D/ ;
		var rs = regx.exec(“userA”);
		结果： 匹配成功， rs的值为： {userA}
		23 > \f：匹配一个换页符。
		24 > \n：匹配一个换行符。因为是换行符，所以在表达式中要加入m参数。
		例子：
		var regx = /a\nbc / m;
		var str = “abc”;
		var rs = regx.exec(str);
		结果： 匹配成功， rs的值为： {}，
		如果表达式为 \ a \ n \ rbc \ ，则不会被匹配， 因此在一般的编辑器中一个” Enter” 键代表着“ 回车换行”， 而非“ 换行回车”， 
		至少在textarea域中是这样的。
		25 > \r：匹配一个回车符
		26 > \s：匹配一个空格符，等同于[ \f\n\r\t\v\u00A0\u2028\u2029].
		例子：
		var regx = /\si/;
		var rs = regx.exec(“Beijing is a city”);
		结果： 匹配成功， rs的值为： {i}
		27 > \S：匹配一个非空格符，等同于[ ^\f\n\r\t\v\u00A0\u2028\u2029].
		例子：
		var regx = /\Si/;
		var rs = regx.exec(“Beijing is a city”);
		结果： 匹配成功， rs的值为： {ei}
		28 > \t：匹配一个tab
		例子：
		var regx = /a\tb/ ;
		var rs = regx.exec(“a bc”);
		结果： 匹配成功， rs的值为： {a bc}
		29 > \v：匹配一个竖向的tab
		30 > \w：匹配一个数字、_或字母表字符，即[A-Za-z0-9_ ]。
		例子：
		var regx = /\w/;
		var rs = regx.exec(“$25.23”);
		结果： 匹配成功， rs的值为： {2}
		31 > \W：匹配一个非数字、_或字母表字符，即[^A-Za-z0-9_ ]。
		例子：
		var regx = /\w/;var rs = regx.exec(“$25.23”);
		结果： 匹配成功， rs的值为： {$}
		32 > \n：注意不是\n，
		这里n是一个正整数， 表示匹配第n个() 中的字符。
		例子：
		var regx = /user([,-])group/
		1 role \ ;
		var rs = regx.exec(“user - group - role”);
		结果： 匹配成功， rs的值为： {user - group - role, -}，
		同样对user, group, role的匹配也是成功的， 但像user - group, role等就不对了。
		33 > \0：匹配一个NUL字符。
		34 > \xhh：匹配一个由两位16进制数字所表达的字符。
		35 > \uhhhh：匹配一个由四位16进制数字所表达的字符。
3， 表达式操作
	1） 表达式操作， 在这里是指和表达式相关的方法， 我们将介绍六个方法。
	2） 表达式对象（ RegExp） 方法：
		1 > exec(str)， 返回str中与表达式相匹配的第一个字符串， 而且以数组的形式表现， 
		当然如果表达式中含有捕捉用的小括号， 则返回的数组中也可能含有() 中的匹配字符串，
		例如：
			var regx = \\d+\;
			var rs = regx.exec(“3432 ddf53”);
			返回的rs值为： {3432}
			var regx2 = new RegExp(“ab(\d+)c”);
			var rs2 = regx2.exec(“ab234c44”); 
			返回的rs值为： {ab234c, 234}
			另外， 如果有多个合适的匹配， 则第一次执行exec返回一个第一个匹配， 此时继续执行exec， 则依次返回第二个第三个匹配。 
			例如：
				var regx = \user\d \ g;
				var rs = regx.exec(“ddduser1dsfuser2dd”);
				var rs1 = regx.exec(“ddduser1dsfuser2dd”); 
				则rs的值为 {user1}，
				rs的值为 {rs2}，
				当然注意regx中的g参数是必须的， 否则无论exec执行多少次， 都返回第一个匹配。 后面还有相关内容涉及到对此想象的解释。
		2 > test(str)， 判断字符串str是否匹配表达式， 返回一个布尔值。 
		例如：
			var regx = \user\d + \g;
			var flag = regx.test(“user12dd”); flag的值为true。
	3） String对象方法
		1 > match(expr)， 返回与expr相匹配的一个字符串数组， 如果没有加参数g， 则返回第一个匹配， 加入参数g则返回所有的匹配 
		例子：
			var regx = \user\d \ g;
			var str = “user13userddduser345”;
			var rs = str.match(regx); rs的值为： {user1, user3}
		2 > search(expr)， 返回字符串中与expr相匹配的第一个匹配的index值。 例子：
			var regx = \user\d \ g;
			var str = “user13userddduser345”;
			var rs = str.search(regx); rs的值为： 0
		3 > replace(expr, str)， 将字符串中匹配expr的部分替换为str。 
		另外在replace方法中， str中可以含有一种变量符号$， 格式为$n， 代表匹配中被记住的第n的匹配字符串（ 注意小括号可以记忆匹配）。 
		例子：
			var regx = \user\d \ g;
			var str = “user13userddduser345”;
			var rs = str.replace(regx, ”00”); rs的值为： 003 userddd0045 例子2：
			var regx = \u(se)r\d \ g;
			var str = “user13userddduser345”;
			var rs = str.replace(regx, ”$1”); rs的值为： se3userdddse45 对于replace(expr, str) 方法还要特别注意一点， 
			如果expr是一个表达式对象则会进行全局替换（ 此时表达式必须附加参数g， 否则也只是替换第一个匹配）， 
			如果expr是一个字符串对象， 则只会替换第一个匹配的部分， 
			例如：
				var regx = “user”
				var str = “user13userddduser345”;
				var rs = str.replace(regx, ”00”); rs的值为： 0013 userddduser345
		4 > split(expr)， 将字符串以匹配expr的部分做分割， 返回一个数组， 而且表达式是否附加参数g都没有关系， 结果是一样的。 
		例子：
			var regx = \user\d \ g;
			var str = “user13userddduser345”;
			var rs = str.split(regx); rs的值为： {3 userddd, 45}

4， 表达式相关属性
	1） 表达式相关属性， 是指和表达式相关的属性， 如下面的形式：
		var regx = \myexpr\;
		var rs = regx.exec(str); 
		其中， 和表达式自身regx相关的属性有两个， 和表达式匹配结果rs相关的属性有三个， 下面将逐一介绍。 
	2） 和表达式自身相关的两个属性：
		1 > lastIndex， 返回开始下一个匹配的位置， 注意必须是全局匹配（ 表达式中带有g参数） 时， 
		lastIndex才会有不断返回下一个匹配值， 否则该值为总是返回第一个下一个匹配位置， 
		例如：
			var regx = \user\d \ ;
			var rs = regx.exec(“sdsfuser1dfsfuser2”);
			var lastIndex1 = regx.lastIndex; rs = regx.exec(“sdsfuser1dfsfuser2”);
			var lastIndex2 = regx.lastIndex; rs = regx.exec(“sdsfuser1dfsfuser2”);
			var lastIndex3 = regx.lastIndex; 上面lastIndex1为9， 第二个lastIndex2也为9， 第三个也是9； 
			如果regx = \user\d \ g， 则第一个为9， 第二个为18， 第三个为0。
		2 > source， 返回表达式字符串自身。 
		例如：
			var regx = \user\d \ ;
			var rs = regx.exec(“sdsfuser1dfsfuser2”);
			var source = regx.source; source的值为user \ d 3
	3） 和匹配结果相关的三个属性：
		1 > index， 返回当前匹配的位置。 
		例如：
			var regx = \user\d \ ;
			var rs = regx.exec(“sdsfuser1dfsfuser2”);
			var index1 = rs.index; rs = regx.exec(“sdsfuser1dfsfuser2”);
			var index2 = rs.index; rs = regx.exec(“sdsfuser1dfsfuser2”);
			var index3 = rs.index; index1为4， index2为4， index3为4， 如果表达式加入参数g， 则index1为4， index2为13， index3会报错（ index为空或不是对象）。
		2 > input， 用于匹配的字符串。 
		例如：
			var regx = \user\d \ ;
			var rs = regx.exec(“sdsfuser1dfsfuser2”);
			var input = rs.input; input的值为sdsfuser1dfsfuser2。
		3 > [0]， 返回匹配结果中的第一个匹配值， 对于match而言可能返回一个多值的数字， 则除了[0] 外， 还可以取[1]、[2] 等等。
		 例如：
			var regx = \user\d \ ;
			var rs = regx.exec(“sdsfuser1dfsfuser2”);
			var value1 = rs[0]; rs = regx.exec(“sdsfuser1dfsfuser2”);
			var value2 = rs[0]; value1的值为user1, value2的值为user2
5， 实际应用
	1） 实际应用一 描述： 有一表单， 其中有一个“ 用户名” input域 要求： 汉字， 而且不能少于2个汉字， 不能多于4个汉字。 
		实现： 
				<script>
					function checkForm(obj) {
						var username = obj.username.value;
						var regx = /^[\u4e00-\u9fa5]{2,4}$/g
						if (!regx.test(username)) {
							alert(“Invalid username!”);
							return false;
						}
						return true;
					} 
				</script> 
				<form name = “myForm” onSubmit = “return checkForm(this)” >
					< input type = “text” name = “username” />
					< input type = “submit” vlaue = “submit” />
				</form>
	2） 实际应用二 描述： 给定一个含有html标记的字符串， 要求将其中的html标记去掉。 
		实现： 
			<script>
				function toPlainText(htmlStr) {
					var regx = /<[^>]*>|<\ \ [ ^ > ] * > /gm;
					var str = htmlStr.replace(regx, "");
					return str;
				} 
			</script> 
			<form name = “myForm” >
				< textarea id = “htmlInput” > </textarea> 
				< input type = “button” value = “submit” onclick = “toPlainText(document.getElementById(‘htmlInput’).value” />
			</form>
三， 小结

	1， Javascript正则表达式， 我想在一般的程序员之中， 使用者应该不是很多， 因为我们处理的页面一般都不是很复杂， 
	而复杂的逻辑一般我们都在后台处理完成了。 但是目前趋势已经出现了扭转， 富客户端已经被越来越多的人接受， 
	而Javascript就是其中的关键技术， 对于复杂的客户端逻辑而言， 正则表达式的作用也是很关键的， 同时它也是Javascript高手必须要掌握的重要技术之一。

	2， 为了能够便于大家对前面讲述的内容有一个更为综合和深刻的认识， 我将前面的一些关键点和容易犯糊涂的地方再系统总结一下， 这部分很关键！ 
	总结1： 附件参数g的用法 表达式加上参数g之后， 表明可以进行全局匹配， 注意这里“ 可以” 的含义。 我们详细叙述： 
		1） 对于表达式对象的exec方法， 不加入g， 则只返回第一个匹配， 无论执行多少次均是如此， 
		如果加入g， 则第一次执行也返回第一个匹配， 再执行返回第二个匹配， 依次类推。 
		例如
			var regx = /user\d/ ;
			var str = “user18dsdfuser2dsfsd”;
			var rs = regx.exec(str); //此时rs的值为{user1}
			var rs2 = regx.exec(str); //此时rs的值依然为{user1}
			如果regx = /user\d/g； 则rs的值为 {user1}，rs2的值为 {user2}
		通过这个例子说明： 对于exec方法， 表达式加入了g， 并不是说执行exec方法就可以返回所有的匹配， 
		而是说加入了g之后， 我可以通过某种方式得到所有的匹配， 这里的“ 方式” 对于exec而言， 就是依次执行这个方法即可。 
		2） 对于表达式对象的test方法， 加入g于不加上g没有什么区别。 
		3） 对于String对象的match方法， 不加入g， 也只是返回第一个匹配， 一直执行match方法也总是返回第一个匹配， 加入g， 
		则一次返回所有的匹配（ 注意这与表达式对象的exec方法不同， 对于exec而言， 表达式即使加上了g， 也不会一次返回所有的匹配）。 
		例如：
			var regx = /user\d/ ;
			var str = “user1sdfsffuser2dfsdf”;
			var rs = str.match(regx); //此时rs的值为{user1}
			var rs2 = str.match(regx); //此时rs的值依然为{user1}
			如果regx = /user\d/ g， 则rs的值为 {user1, user2}，rs2的值也为 {user1, user2}
		4） 对于String对象的replace方法， 表达式不加入g， 则只替换第一个匹配， 如果加入g， 则替换所有匹配。
		（ 开头的三道测试题能很好的说明这一点） 
		5） 对于String对象的split方法， 加上g与不加g是一样的， 
		即：
			var sep = /user\d/ ;
			var array = “user1dfsfuser2dfsf”.split(sep); 
			则array的值为 {dfsf, dfsf}
			此时sep = /user\d/g， 返回值是一样的。 
		6） 对于String对象的search方法， 加不加g也是一样的。 
	总结2： 附加参数m的用法 附加参数m， 表明可以进行多行匹配， 但是这个只有当使用 ^ 和$模式时才会起作用， 
	在其他的模式中， 加不加入m都可以进行多行匹配（ 其实说多行的字符串也是一个普通字符串）， 我们举例说明这一点
	1） 使用 ^ 的例子
			var regx = /^b./g;
			var str = “bd76 dfsdfsdfsdfs dffs b76dsf sdfsdf”;
			var rs = str.match(regx); 此时加入g和不加入g， 都只返回第一个匹配 {bd}，
			如果regx = /^b./gm，则返回所有的匹配 {bd, b7}，
			注意如果regx = \^b.\m，则也只返回第一个匹配。 
			所以， 加入m表明可以进行多行匹配， 加入g表明可以进行全局匹配， 综合到一起就是可以进行多行全局匹配
	2） 使用其他模式的例子， 例如
		var regx = /user\d/ ;
		var str = “sdfsfsdfsdfsdfsuser3 dffs b76dsf user6”;
		var rs = str.match(regx); 此时不加参数g， 则返回 {user3}，
		加入参数g返回 {user3, user6}，加不加入m对此没有影响。 
	3） 因此对于m我们要清楚它的使用， 记住它只对 ^ 和$模式起作用， 在这两种模式中， m的作用为： 如果不加入m， 则只能在第一行进行匹配，
	    如果加入m则可以在所有的行进行匹配。 
	    我们再看一个 ^ 的例子
			var regx = /^b./;
			var str = “ret76 dfsdfbjfsdfs dffs b76dsf sdfsdf”;
			var rs = str.match(regx); 此时rs的值为null， 如果加入g， rs的值仍然为null， 如果加入m， 则rs的值为 {bj}
			（也就是说， 在第一行没有找到匹配， 因为有参数m， 所以可以继续去下面的行去找是否有匹配）， 
			如果m和g都加上， 则返回 {bj, b7}（只加m不加g说明， 可以去多行进行匹配， 但是找到一个匹配后就返回， 
			加入g表明将多行中所有的匹配返回， 当然对于match方法是如此， 对于exec呢， 则需要执行多次才能依次返回） 
	总结3： 在HTML的textarea输入域中， 按一个Enter键， 对应的控制字符为“ \ r \ n”， 即“ 回车换行”， 而不是“ \ n \ r”， 
		即“ 换行回车”， 我们看一个前面我们举过的例子：
			var regx = /a\r \ nbc/ ;
			var str = “abc”;
			var rs = regx.exec(str); 结果： 匹配成功， rs的值为： {}，
			如果表达式为 / a \ n \ rbc/ ，则不会被匹配， 因此在一般的编辑器中一个” Enter” 键代表着“ 回车换行”， 
			而非“ 换行回车”， 至少在textarea域中是这样的。
```
